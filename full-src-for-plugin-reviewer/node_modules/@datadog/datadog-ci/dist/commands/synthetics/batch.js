"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportReceivedResults = exports.getResultsToReport = exports.waitForBatchToFinish = void 0;
const deep_extend_1 = __importDefault(require("deep-extend"));
const api_1 = require("./api");
const errors_1 = require("./errors");
const internal_1 = require("./utils/internal");
const public_1 = require("./utils/public");
const POLLING_INTERVAL = 5000; // In ms
const waitForBatchToFinish = (api, batchId, batchTimeout, resultDisplayInfo, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    const safeDeadline = Date.now() + batchTimeout + 3 * POLLING_INTERVAL;
    const emittedResultIds = new Set();
    const backupPollResultMap = new Map();
    let oldIncompleteResultIds = new Set();
    while (true) {
        const batch = yield getBatch(api, batchId);
        const safeDeadlineReached = Date.now() >= safeDeadline;
        // The backend is expected to handle the time out of the batch by eventually changing its status to `failed`.
        // But `safeDeadlineReached` is a safety in case it fails to do that on time.
        const shouldContinuePolling = batch.status === 'in_progress' && !safeDeadlineReached;
        const newlyReceivedResults = (0, exports.reportReceivedResults)(batch, emittedResultIds, reporter);
        const resultIdsToFetch = getResultIdsToFetch(shouldContinuePolling, batch, newlyReceivedResults, oldIncompleteResultIds);
        const { pollResultMap, incompleteResultIds } = yield getPollResultMap(api, resultIdsToFetch, backupPollResultMap);
        const resultsToReport = (0, exports.getResultsToReport)(shouldContinuePolling, batch, newlyReceivedResults, emittedResultIds, oldIncompleteResultIds, incompleteResultIds, reporter);
        reportResults(batchId, resultsToReport, pollResultMap, resultDisplayInfo, safeDeadlineReached, reporter);
        oldIncompleteResultIds = incompleteResultIds;
        if (safeDeadlineReached) {
            throw new errors_1.BatchTimeoutRunawayError();
        }
        if (!shouldContinuePolling) {
            return batch.results.map((r) => getResultFromBatch(r, pollResultMap, resultDisplayInfo));
        }
        reportWaitingTests(batchId, batch, resultDisplayInfo, reporter);
        yield (0, public_1.wait)(POLLING_INTERVAL);
    }
});
exports.waitForBatchToFinish = waitForBatchToFinish;
const getResultIdsToFetch = (shouldContinuePolling, batch, newlyReceivedResults, oldIncompleteResultIds) => {
    // For the last iteration, the full up-to-date data has to be fetched to compute the return value of `waitForResults()`.
    if (!shouldContinuePolling) {
        return getResultIds(batch.results);
    }
    return getResultIds(newlyReceivedResults).concat(...oldIncompleteResultIds);
};
const getResultsToReport = (shouldContinuePolling, batch, newlyReceivedResults, emittedResultIds, oldIncompleteResultIds, incompleteResultIds, reporter) => {
    const newlyCompleteResults = excludeSkipped(batch.results).filter((r) => oldIncompleteResultIds.has(r.result_id) && !incompleteResultIds.has(r.result_id));
    const resultsToReport = newlyReceivedResults
        .filter((r) => (0, internal_1.isResultInBatchSkippedBySelectiveRerun)(r) || !isResidualResult(r, emittedResultIds, incompleteResultIds))
        .concat(newlyCompleteResults);
    if (shouldContinuePolling) {
        return resultsToReport;
    }
    // Results that we failed to report for some reason are finally reported as "residues".
    const residualResults = excludeSkipped(batch.results).filter((r) => isResidualResult(r, emittedResultIds, incompleteResultIds));
    const errors = [];
    for (const result of residualResults) {
        if (!result.timed_out) {
            errors.push(`The information for result ${result.result_id} of test ${result.test_public_id} was incomplete at the end of the batch.`);
        }
    }
    if (errors.length > 0) {
        reporter.error(errors.join('\n') + '\n\n');
    }
    return resultsToReport.concat(residualResults);
};
exports.getResultsToReport = getResultsToReport;
const reportReceivedResults = (batch, emittedResultIds, reporter) => {
    const receivedResults = [];
    for (const [index, result] of batch.results.entries()) {
        // Skipped results are only reported by `resultReceived()`, then they are excluded everywhere with `excludeSkipped()`.
        const resultId = result.status === 'skipped' ? `skipped-${index}` : result.result_id;
        // The result is reported if it has a final status, or if it's a non-final result.
        if ((result.status !== 'in_progress' || (0, internal_1.isNonFinalResult)(result)) && !emittedResultIds.has(resultId)) {
            emittedResultIds.add(resultId);
            reporter.resultReceived(result);
            receivedResults.push(result);
        }
    }
    return receivedResults;
};
exports.reportReceivedResults = reportReceivedResults;
const reportResults = (batchId, results, pollResultMap, resultDisplayInfo, safeDeadlineReached, reporter) => {
    const baseUrl = (0, public_1.getAppBaseURL)(resultDisplayInfo.options);
    for (const result of results) {
        reporter.resultEnd(getResultFromBatch(result, pollResultMap, resultDisplayInfo, safeDeadlineReached), baseUrl, batchId);
    }
};
const reportWaitingTests = (batchId, batch, resultDisplayInfo, reporter) => {
    const baseUrl = (0, public_1.getAppBaseURL)(resultDisplayInfo.options);
    const { tests } = resultDisplayInfo;
    const inProgressPublicIds = new Set();
    const skippedBySelectiveRerunPublicIds = new Set();
    for (const result of batch.results) {
        if (result.status === 'in_progress') {
            inProgressPublicIds.add(result.test_public_id);
        }
        if ((0, internal_1.isResultInBatchSkippedBySelectiveRerun)(result)) {
            skippedBySelectiveRerunPublicIds.add(result.test_public_id);
        }
    }
    const remainingTests = [];
    let skippedCount = 0;
    for (const test of tests) {
        if (inProgressPublicIds.has(test.public_id)) {
            remainingTests.push(test);
        }
        if (skippedBySelectiveRerunPublicIds.has(test.public_id)) {
            skippedCount++;
        }
    }
    reporter.testsWait(remainingTests, baseUrl, batchId, skippedCount);
};
const getResultFromBatch = (resultInBatch, pollResultMap, resultDisplayInfo, safeDeadlineReached = false) => {
    var _a, _b, _c;
    const { tests } = resultDisplayInfo;
    const test = getTestByPublicId(resultInBatch.test_public_id, tests);
    const hasTimedOut = (_a = resultInBatch.timed_out) !== null && _a !== void 0 ? _a : safeDeadlineReached;
    const timedOutRetry = (0, internal_1.isTimedOutRetry)(resultInBatch.retries, resultInBatch.max_retries, resultInBatch.timed_out);
    if ((0, internal_1.isResultInBatchSkippedBySelectiveRerun)(resultInBatch)) {
        return {
            executionRule: resultInBatch.execution_rule,
            passed: true,
            resultId: (0, internal_1.getResultIdOrLinkedResultId)(resultInBatch),
            selectiveRerun: resultInBatch.selective_rerun,
            test,
            timedOut: hasTimedOut,
        };
    }
    const pollResult = pollResultMap.get(resultInBatch.result_id);
    const isUnhealthy = (_c = (_b = pollResult === null || pollResult === void 0 ? void 0 : pollResult.result) === null || _b === void 0 ? void 0 : _b.unhealthy) !== null && _c !== void 0 ? _c : false;
    if (!(pollResult === null || pollResult === void 0 ? void 0 : pollResult.result)) {
        return createResult(resultInBatch, pollResult, test, hasTimedOut, isUnhealthy, resultDisplayInfo);
    }
    if (safeDeadlineReached) {
        pollResult.result.failure = new errors_1.BatchTimeoutRunawayError().toJson();
        pollResult.result.passed = false;
    }
    else if (timedOutRetry) {
        pollResult.result.failure = { code: 'TIMEOUT', message: 'The batch timed out before receiving the retry.' };
        pollResult.result.passed = false;
    }
    else if (hasTimedOut) {
        pollResult.result.failure = { code: 'TIMEOUT', message: 'The batch timed out before receiving the result.' };
        pollResult.result.passed = false;
    }
    return createResult(resultInBatch, pollResult, test, hasTimedOut, isUnhealthy, resultDisplayInfo);
};
const createResult = (resultInBatch, pollResult, test, hasTimedOut, isUnhealthy, { getLocation, options }) => {
    var _a;
    return {
        duration: resultInBatch.duration,
        executionRule: resultInBatch.execution_rule,
        initialResultId: resultInBatch.initial_result_id,
        isNonFinal: (0, internal_1.isNonFinalResult)(resultInBatch),
        location: getLocation(resultInBatch.location, test),
        passed: (0, internal_1.hasResultPassed)(resultInBatch, isUnhealthy, hasTimedOut, options),
        result: pollResult === null || pollResult === void 0 ? void 0 : pollResult.result,
        resultId: (0, internal_1.getResultIdOrLinkedResultId)(resultInBatch),
        retries: resultInBatch.retries || 0,
        maxRetries: resultInBatch.max_retries || 0,
        selectiveRerun: resultInBatch.selective_rerun,
        test: (0, deep_extend_1.default)({}, test, pollResult === null || pollResult === void 0 ? void 0 : pollResult.check),
        timedOut: hasTimedOut,
        timestamp: (_a = pollResult === null || pollResult === void 0 ? void 0 : pollResult.timestamp) !== null && _a !== void 0 ? _a : Date.now(),
    };
};
const getBatch = (api, batchId) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    try {
        const batch = yield api.getBatch(batchId);
        return batch;
    }
    catch (e) {
        throw new api_1.EndpointError(`Failed to get batch: ${(0, api_1.formatBackendErrors)(e)}\n`, (_a = e.response) === null || _a === void 0 ? void 0 : _a.status);
    }
});
/**
 * Returns fresh poll results, or reads the backup map in case of 404.
 */
const getPollResultMap = (api, resultIds, backupPollResultMap) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const pollResultMap = new Map();
    const incompleteResultIds = new Set();
    try {
        const pollResults = yield api.pollResults(resultIds);
        pollResults.forEach((r) => {
            // Server results are initialized to `{"eventType": "created"}` in the backend, and they may take
            // some time to be updated. In that case, we keep the `PollResult` information (e.g. `timestamp`)
            // but remove the server result to avoid reporting an unexpected object shape.
            if (r.result && 'eventType' in r.result && r.result.eventType === 'created') {
                incompleteResultIds.add(r.resultID);
                delete r.result;
            }
            pollResultMap.set(r.resultID, r);
            backupPollResultMap.set(r.resultID, r);
        });
        return { pollResultMap, incompleteResultIds };
    }
    catch (e) {
        if ((0, api_1.getErrorHttpStatus)(e) === 404) {
            // If some results have latency and retries were not enough, the whole request fails with "Test results not found".
            // In that case, we mark results IDs that were never polled before as incomplete so they are fetched in the next polling cycles.
            resultIds.forEach((resultId) => {
                const backupPollResult = backupPollResultMap.get(resultId);
                if (backupPollResult) {
                    pollResultMap.set(resultId, backupPollResult);
                }
                else {
                    incompleteResultIds.add(resultId);
                }
            });
            return { pollResultMap, incompleteResultIds };
        }
        throw new api_1.EndpointError(`Failed to poll results: ${(0, api_1.formatBackendErrors)(e)}\n`, (_b = e.response) === null || _b === void 0 ? void 0 : _b.status);
    }
});
/**
 * A residual result is either:
 * - Still incomplete (from the poll results POV): report it with incomplete data and a warning.
 * - Still in progress (from the batch POV): it was never emitted.
 * - A timed out retry.
 */
const isResidualResult = (result, emittedResultIds, incompleteResultIds) => {
    if (incompleteResultIds.has(result.result_id)) {
        // The poll results endpoint returned an incomplete result: report it with incomplete data and a warning.
        return true;
    }
    if (!emittedResultIds.has(result.result_id)) {
        // Was never emitted, which means the batch never set a final status for it.
        return true;
    }
    if (emittedResultIds.has(result.result_id) && (0, internal_1.isTimedOutRetry)(result.retries, result.max_retries, result.timed_out)) {
        // The result ID was already emitted but it used to be non-final result, and it's now a timed out retry.
        return true;
    }
    return false;
};
const getTestByPublicId = (id, tests) => tests.find((t) => t.public_id === id);
const getResultIds = (results) => excludeSkipped(results).map((r) => r.result_id);
const excludeSkipped = (results) => results.filter((r) => !(0, internal_1.isResultInBatchSkippedBySelectiveRerun)(r));
//# sourceMappingURL=batch.js.map