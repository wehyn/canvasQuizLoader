"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.warnIfDeprecatedPollingTimeoutUsed = exports.warnIfDeprecatedConfigUsed = exports.replacePollingTimeoutWithBatchTimeout = exports.replaceGlobalWithDefaultTestOverrides = exports.replaceConfigWithTestOverrides = exports.moveLocationsToTestOverrides = void 0;
const run_tests_command_1 = require("./run-tests-command");
const moveLocationsToTestOverrides = (config, reporter, warnDeprecatedLocations = false) => {
    var _a, _b, _c;
    const isLocationsUsedInRoot = ((_a = config.locations) !== null && _a !== void 0 ? _a : []).length !== 0;
    // At this point, `global` should already have been moved to `defaultTestOverrides`
    const isLocationsUsedInDefaultTestOverrides = ((_c = (_b = config.defaultTestOverrides) === null || _b === void 0 ? void 0 : _b.locations) !== null && _c !== void 0 ? _c : []).length !== 0;
    if (isLocationsUsedInRoot && warnDeprecatedLocations) {
        reporter.error("The 'locations' property should not be used at the root level of the global configuration file. Please put it in 'defaultTestOverrides' instead.\n If 'locations' exists in both places, only the one in 'defaultTestOverrides' is used!\n");
    }
    // If the user hasn't migrated and is still using `locations` at the root level, move it in the `defaultTestOverrides`
    if (!isLocationsUsedInDefaultTestOverrides && isLocationsUsedInRoot) {
        return Object.assign(Object.assign({}, config), { defaultTestOverrides: Object.assign(Object.assign({}, config.defaultTestOverrides), { locations: config.locations }) });
    }
    return config;
};
exports.moveLocationsToTestOverrides = moveLocationsToTestOverrides;
const replaceConfigWithTestOverrides = (config, testOverrides) => {
    const isConfigUsed = Object.keys(config !== null && config !== void 0 ? config : {}).length !== 0;
    const isTestOverridesUsed = Object.keys(testOverrides !== null && testOverrides !== void 0 ? testOverrides : {}).length !== 0;
    // If the user hasn't migrated and is still using `config` in test files, use `config`
    if (!isTestOverridesUsed && isConfigUsed) {
        return config !== null && config !== void 0 ? config : {};
    }
    return testOverrides !== null && testOverrides !== void 0 ? testOverrides : {};
};
exports.replaceConfigWithTestOverrides = replaceConfigWithTestOverrides;
const replaceGlobalWithDefaultTestOverrides = (config, reporter, warnDeprecatedGlobal = false) => {
    var _a, _b;
    // The user is able to put both if they don't use the library in TS or use configuration files.
    const isGlobalUsed = Object.keys((_a = config.global) !== null && _a !== void 0 ? _a : {}).length !== 0;
    const isDefaultTestOverridesUsed = Object.keys((_b = config.defaultTestOverrides) !== null && _b !== void 0 ? _b : {}).length !== 0;
    if (isGlobalUsed && warnDeprecatedGlobal) {
        reporter.error("The 'global' property is deprecated. Please use 'defaultTestOverrides' instead.\nIf both 'global' and 'defaultTestOverrides' properties exist, 'defaultTestOverrides' is used!\n");
    }
    // If the user hasn't migrated and is still using `global`, use `global`
    if (!isDefaultTestOverridesUsed && isGlobalUsed) {
        return Object.assign(Object.assign({}, config), { defaultTestOverrides: Object.assign({}, config.global) });
    }
    return config;
};
exports.replaceGlobalWithDefaultTestOverrides = replaceGlobalWithDefaultTestOverrides;
const replacePollingTimeoutWithBatchTimeout = (config, reporter, warnDeprecatedPollingTimeout = false, batchTimeoutCliParam, pollingTimeoutCliParam) => {
    var _a, _b;
    // At this point, `global` should already have been moved to `defaultTestOverrides`
    const pollingTimeout = (_b = pollingTimeoutCliParam !== null && pollingTimeoutCliParam !== void 0 ? pollingTimeoutCliParam : (_a = config.defaultTestOverrides) === null || _a === void 0 ? void 0 : _a.pollingTimeout) !== null && _b !== void 0 ? _b : config.pollingTimeout;
    const isPollingTimeoutUsed = pollingTimeout !== undefined && pollingTimeout !== run_tests_command_1.DEFAULT_POLLING_TIMEOUT;
    if (isPollingTimeoutUsed && warnDeprecatedPollingTimeout) {
        reporter.error("The 'pollingTimeout' property is deprecated. Please use 'batchTimeout' instead.\nIf both 'pollingTimeout' and 'batchTimeout' properties exist, 'batchTimeout' is used!\n");
    }
    const batchTimeout = batchTimeoutCliParam !== null && batchTimeoutCliParam !== void 0 ? batchTimeoutCliParam : config.batchTimeout;
    const isBatchTimeoutUsed = batchTimeout !== run_tests_command_1.DEFAULT_BATCH_TIMEOUT;
    // If the user hasn't migrated and is still using `pollingTimeout`, use `pollingTimeout`
    if (!isBatchTimeoutUsed && isPollingTimeoutUsed) {
        return Object.assign(Object.assign({}, config), { pollingTimeout, batchTimeout: pollingTimeout });
    }
    // If the current call comes from the CLI, keep using both to make the future call by the command show a warning.
    const calledByCli = !warnDeprecatedPollingTimeout;
    if (calledByCli && isBatchTimeoutUsed && isPollingTimeoutUsed) {
        return Object.assign(Object.assign({}, config), { batchTimeout, pollingTimeout: batchTimeout });
    }
    return config;
};
exports.replacePollingTimeoutWithBatchTimeout = replacePollingTimeoutWithBatchTimeout;
const warnIfDeprecatedConfigUsed = (suites, reporter) => {
    // TODO SYNTH-12989: Clean up deprecated `config` in favor of `testOverrides`
    const isUsingConfig = suites.some((suite) => suite.content.tests.some((test) => { var _a; return Object.keys((_a = test.config) !== null && _a !== void 0 ? _a : {}).length > 0; }));
    if (isUsingConfig) {
        reporter.error("The 'config' property is deprecated. Please use 'testOverrides' instead.\nIf both 'config' and 'testOverrides' properties exist, 'testOverrides' is used!\n");
    }
};
exports.warnIfDeprecatedConfigUsed = warnIfDeprecatedConfigUsed;
const warnIfDeprecatedPollingTimeoutUsed = (suites, reporter) => {
    // TODO SYNTH-12989: Clean up deprecated `pollingTimeout` in favor of `batchTimeout`
    const isUsingPollingTimeout = suites.some((suite) => suite.content.tests.some((test) => { var _a, _b; return ((_a = test.config) === null || _a === void 0 ? void 0 : _a.pollingTimeout) !== undefined || ((_b = test.testOverrides) === null || _b === void 0 ? void 0 : _b.pollingTimeout) !== undefined; }));
    if (isUsingPollingTimeout) {
        reporter.error("The 'pollingTimeout' property is deprecated. Please use 'batchTimeout' in the global configuration file or '--batchTimeout' instead.\nIf both 'pollingTimeout' and 'batchTimeout' properties exist, 'batchTimeout' is used!\n");
    }
};
exports.warnIfDeprecatedPollingTimeoutUsed = warnIfDeprecatedPollingTimeoutUsed;
//# sourceMappingURL=compatibility.js.map