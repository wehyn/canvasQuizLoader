"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportCiError = exports.pluralize = exports.getDatadogHost = exports.toExitCode = exports.getExitReason = exports.reportExitLogs = exports.renderResults = exports.sortResultsByOutcome = exports.getResultUrl = exports.getBatchUrl = exports.getAppBaseURL = exports.parseVariablesFromCli = exports.retry = exports.fetchTest = exports.runTests = exports.getTestsToTrigger = exports.isDeviceIdSet = exports.getTestAndOverrideConfig = exports.getReporter = exports.getResultDuration = exports.createInitialSummary = exports.waitForResults = exports.isResultSkippedBySelectiveRerun = exports.getOrgSettings = exports.normalizePublicId = exports.wait = exports.getFilePathRelativeToRepo = exports.getSuites = exports.getResultOutcome = exports.PASSED_RESULT_OUTCOMES = exports.hasResultPassed = exports.isTestSupportedByTunnel = exports.getStrictestExecutionRule = exports.getExecutionRule = exports.setCiTriggerApp = exports.getTestOverridesCount = exports.getOverriddenConfig = exports.makeTestPayload = exports.ciTriggerApp = exports.readableOperation = exports.PUBLIC_ID_REGEX = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const process_1 = __importDefault(require("process"));
const util_1 = require("util");
const chalk_1 = __importDefault(require("chalk"));
const glob_1 = __importDefault(require("glob"));
const app_1 = require("../../../helpers/app");
const ci_1 = require("../../../helpers/ci");
const tags_1 = require("../../../helpers/tags");
const api_1 = require("../api");
const batch_1 = require("../batch");
const compatibility_1 = require("../compatibility");
const errors_1 = require("../errors");
const interfaces_1 = require("../interfaces");
const mobile_1 = require("../mobile");
const run_tests_command_1 = require("../run-tests-command");
const test_1 = require("../test");
const internal_1 = require("./internal");
exports.PUBLIC_ID_REGEX = /\b[a-z0-9]{3}-[a-z0-9]{3}-[a-z0-9]{3}\b/;
exports.readableOperation = {
    [interfaces_1.Operator.contains]: 'should contain',
    [interfaces_1.Operator.doesNotContain]: 'should not contain',
    [interfaces_1.Operator.is]: 'should be',
    [interfaces_1.Operator.isNot]: 'should not be',
    [interfaces_1.Operator.lessThan]: 'should be less than',
    [interfaces_1.Operator.matches]: 'should match',
    [interfaces_1.Operator.doesNotMatch]: 'should not match',
    [interfaces_1.Operator.isInLessThan]: 'will expire in less than',
    [interfaces_1.Operator.isInMoreThan]: 'will expire in more than',
    [interfaces_1.Operator.lessThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.moreThan]: 'should be more than',
    [interfaces_1.Operator.moreThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.validatesJSONPath]: 'assert on JSONPath extracted value',
    [interfaces_1.Operator.validatesXPath]: 'assert on XPath extracted value',
};
exports.ciTriggerApp = process_1.default.env.DATADOG_SYNTHETICS_CI_TRIGGER_APP || 'npm_package';
const makeTestPayload = (test, triggerConfig, publicId) => {
    if ((0, internal_1.isLocalTriggerConfig)(triggerConfig)) {
        return Object.assign(Object.assign({}, (0, internal_1.getBasePayload)(test, triggerConfig.testOverrides)), { local_test_definition: triggerConfig.local_test_definition });
    }
    return Object.assign(Object.assign({}, (0, internal_1.getBasePayload)(test, triggerConfig.testOverrides)), { public_id: publicId });
};
exports.makeTestPayload = makeTestPayload;
/** @deprecated This function doesn't work for local test definitions. Please use {@link makeTestPayload} instead. */
const getOverriddenConfig = (test, publicId, reporter, testOverrides) => {
    return Object.assign(Object.assign({}, (0, internal_1.getBasePayload)(test, testOverrides)), { public_id: publicId });
};
exports.getOverriddenConfig = getOverriddenConfig;
const getTestOverridesCount = (testOverrides) => {
    return Object.keys(testOverrides).reduce((count, configKey) => {
        // TODO SYNTH-12989: Clean up deprecated `pollingTimeout`
        // We always send a value for `pollingTimeout` to the backend, even when the user doesn't override it.
        // In that case, it shouldn't be counted.
        if (configKey === 'pollingTimeout' && testOverrides[configKey] === run_tests_command_1.DEFAULT_POLLING_TIMEOUT) {
            return count;
        }
        return count + 1;
    }, 0);
};
exports.getTestOverridesCount = getTestOverridesCount;
const setCiTriggerApp = (source) => {
    exports.ciTriggerApp = source;
};
exports.setCiTriggerApp = setCiTriggerApp;
const getExecutionRule = (test, configOverride) => {
    var _a, _b, _c, _d;
    if (configOverride && configOverride.executionRule) {
        return (0, exports.getStrictestExecutionRule)(configOverride.executionRule, (_b = (_a = test === null || test === void 0 ? void 0 : test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule);
    }
    return ((_d = (_c = test === null || test === void 0 ? void 0 : test.options) === null || _c === void 0 ? void 0 : _c.ci) === null || _d === void 0 ? void 0 : _d.executionRule) || interfaces_1.ExecutionRule.BLOCKING;
};
exports.getExecutionRule = getExecutionRule;
const getStrictestExecutionRule = (configRule, testRule) => {
    if (configRule === interfaces_1.ExecutionRule.SKIPPED || testRule === interfaces_1.ExecutionRule.SKIPPED) {
        return interfaces_1.ExecutionRule.SKIPPED;
    }
    if (configRule === interfaces_1.ExecutionRule.NON_BLOCKING || testRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return interfaces_1.ExecutionRule.NON_BLOCKING;
    }
    if (configRule === interfaces_1.ExecutionRule.BLOCKING || testRule === interfaces_1.ExecutionRule.BLOCKING) {
        return interfaces_1.ExecutionRule.BLOCKING;
    }
    return interfaces_1.ExecutionRule.BLOCKING;
};
exports.getStrictestExecutionRule = getStrictestExecutionRule;
const isTestSupportedByTunnel = (test) => {
    var _a;
    // Test public IDs are required by the tunnel.
    if (!test.public_id) {
        return false;
    }
    return (test.type === 'browser' ||
        test.subtype === 'http' ||
        (test.subtype === 'multi' && ((_a = test.config.steps) === null || _a === void 0 ? void 0 : _a.every((step) => step.subtype === 'http'))));
};
exports.isTestSupportedByTunnel = isTestSupportedByTunnel;
/**
 * @deprecated The concept of `ServerResult` is internal and not the source of truth for a result's status. This function has no public equivalent.
 */
const hasResultPassed = (serverResult, hasTimedOut, failOnCriticalErrors, failOnTimeout) => {
    if ((serverResult === null || serverResult === void 0 ? void 0 : serverResult.unhealthy) && !failOnCriticalErrors) {
        return true;
    }
    if (hasTimedOut && !failOnTimeout) {
        return true;
    }
    if ((serverResult === null || serverResult === void 0 ? void 0 : serverResult.passed) !== undefined) {
        return serverResult.passed;
    }
    if ((serverResult === null || serverResult === void 0 ? void 0 : serverResult.failure) !== undefined) {
        return false;
    }
    return true;
};
exports.hasResultPassed = hasResultPassed;
exports.PASSED_RESULT_OUTCOMES = [
    "passed" /* ResultOutcome.Passed */,
    "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */,
    "previously-passed" /* ResultOutcome.PreviouslyPassed */,
];
const getResultOutcome = (result) => {
    if ((0, exports.isResultSkippedBySelectiveRerun)(result)) {
        return "previously-passed" /* ResultOutcome.PreviouslyPassed */;
    }
    const executionRule = result.executionRule;
    if (result.passed) {
        if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
            return "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */;
        }
        return "passed" /* ResultOutcome.Passed */;
    }
    if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return "failed-non-blocking" /* ResultOutcome.FailedNonBlocking */;
    }
    return "failed" /* ResultOutcome.Failed */;
};
exports.getResultOutcome = getResultOutcome;
const getSuites = (GLOB, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    reporter.log(`Finding files matching ${path.resolve(process_1.default.cwd(), GLOB)}\n`);
    const files = yield (0, util_1.promisify)(glob_1.default)(GLOB);
    if (files.length) {
        reporter.log(`\nGot test files:\n${files.map((file) => `  - ${file}\n`).join('')}\n`);
    }
    else {
        reporter.log('\nNo test files found.\n\n');
    }
    return Promise.all(files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const content = yield (0, util_1.promisify)(fs.readFile)(file, 'utf8');
            const suiteName = yield (0, exports.getFilePathRelativeToRepo)(file);
            return { name: suiteName, content: JSON.parse(content) };
        }
        catch (e) {
            throw new Error(`Unable to read and parse the test file ${file}`);
        }
    })));
});
exports.getSuites = getSuites;
const getFilePathRelativeToRepo = (filePath) => __awaiter(void 0, void 0, void 0, function* () {
    const parentDirectory = path.dirname(filePath);
    const filename = path.basename(filePath);
    let relativeDirectory;
    try {
        const { stdout } = yield (0, util_1.promisify)(child_process_1.exec)('git rev-parse --show-toplevel');
        const repoTopLevel = stdout.trim();
        relativeDirectory = path.relative(repoTopLevel, parentDirectory);
    }
    catch (_a) {
        // We aren't in a git repository: fall back to the given path, relative to the process working directory.
        relativeDirectory = path.relative(process_1.default.cwd(), parentDirectory);
    }
    return path.join(relativeDirectory, filename);
});
exports.getFilePathRelativeToRepo = getFilePathRelativeToRepo;
const wait = (duration) => __awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, duration)); });
exports.wait = wait;
const normalizePublicId = (id) => { var _a; return id === internal_1.LOCAL_TEST_DEFINITION_PUBLIC_ID_PLACEHOLDER ? id : (_a = id.match(exports.PUBLIC_ID_REGEX)) === null || _a === void 0 ? void 0 : _a[0]; };
exports.normalizePublicId = normalizePublicId;
const getOrgSettings = (reporter, config) => __awaiter(void 0, void 0, void 0, function* () {
    const apiHelper = (0, api_1.getApiHelper)(config);
    try {
        return yield apiHelper.getSyntheticsOrgSettings();
    }
    catch (e) {
        reporter.error(`Failed to get settings: ${(0, api_1.formatBackendErrors)(e, 'synthetics_default_settings_read')}`);
    }
});
exports.getOrgSettings = getOrgSettings;
const isResultSkippedBySelectiveRerun = (result) => {
    var _a;
    return ((_a = result.selectiveRerun) === null || _a === void 0 ? void 0 : _a.decision) === 'skip';
};
exports.isResultSkippedBySelectiveRerun = isResultSkippedBySelectiveRerun;
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const waitForResults = (api, trigger, tests, options, reporter, tunnel) => __awaiter(void 0, void 0, void 0, function* () {
    let isTunnelConnected = true;
    if (tunnel) {
        tunnel
            .keepAlive()
            .then(() => (isTunnelConnected = false))
            .catch(() => (isTunnelConnected = false));
    }
    reporter.testsWait(tests, (0, exports.getAppBaseURL)(options), trigger.batch_id);
    const locationNames = trigger.locations.reduce((mapping, location) => {
        mapping[location.name] = location.display_name;
        return mapping;
    }, {});
    const getLocation = (dcId, test) => {
        const hasTunnel = !!tunnel && (0, exports.isTestSupportedByTunnel)(test);
        return hasTunnel ? 'Tunneled' : locationNames[dcId] || dcId;
    };
    const resultDisplayInfo = {
        getLocation,
        options,
        tests,
    };
    const results = yield (0, batch_1.waitForBatchToFinish)(api, trigger.batch_id, options.batchTimeout, resultDisplayInfo, reporter);
    if (tunnel && !isTunnelConnected) {
        reporter.error('The tunnel has stopped working, this may have affected the results.');
    }
    return results;
});
exports.waitForResults = waitForResults;
const createInitialSummary = () => ({
    criticalErrors: 0,
    expected: 0,
    failed: 0,
    failedNonBlocking: 0,
    passed: 0,
    previouslyPassed: 0,
    skipped: 0,
    testsNotFound: new Set(),
    timedOut: 0,
});
exports.createInitialSummary = createInitialSummary;
/**
 * @deprecated Please use `Result.duration` instead.
 */
const getResultDuration = (result) => {
    if ('duration' in result) {
        return Math.round(result.duration);
    }
    if ('timings' in result) {
        return Math.round(result.timings.total);
    }
    return 0;
};
exports.getResultDuration = getResultDuration;
const getReporter = (reporters) => ({
    error: (error) => {
        for (const reporter of reporters) {
            if (typeof reporter.error === 'function') {
                reporter.error(error);
            }
        }
    },
    initErrors: (errors) => {
        for (const reporter of reporters) {
            if (typeof reporter.initErrors === 'function') {
                reporter.initErrors(errors);
            }
        }
    },
    log: (log) => {
        for (const reporter of reporters) {
            if (typeof reporter.log === 'function') {
                reporter.log(log);
            }
        }
    },
    reportStart: (timings) => {
        for (const reporter of reporters) {
            if (typeof reporter.reportStart === 'function') {
                reporter.reportStart(timings);
            }
        }
    },
    resultEnd: (result, baseUrl, batchId) => {
        for (const reporter of reporters) {
            if (typeof reporter.resultEnd === 'function') {
                reporter.resultEnd(result, baseUrl, batchId);
            }
        }
    },
    resultReceived: (result) => {
        for (const reporter of reporters) {
            if (typeof reporter.resultReceived === 'function') {
                reporter.resultReceived(result);
            }
        }
    },
    runEnd: (summary, baseUrl, orgSettings) => {
        for (const reporter of reporters) {
            if (typeof reporter.runEnd === 'function') {
                reporter.runEnd(summary, baseUrl, orgSettings);
            }
        }
    },
    testTrigger: (test, testId, executionRule, testOverrides) => {
        for (const reporter of reporters) {
            if (typeof reporter.testTrigger === 'function') {
                reporter.testTrigger(test, testId, executionRule, testOverrides);
            }
        }
    },
    testWait: (test) => {
        for (const reporter of reporters) {
            if (typeof reporter.testWait === 'function') {
                reporter.testWait(test);
            }
        }
    },
    testsWait: (tests, baseUrl, batchId, skippedCount) => {
        for (const reporter of reporters) {
            if (typeof reporter.testsWait === 'function') {
                reporter.testsWait(tests, baseUrl, batchId, skippedCount);
            }
        }
    },
});
exports.getReporter = getReporter;
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const getTestAndOverrideConfig = (api, 
// TODO SYNTH-12989: Clean up deprecated `config` in favor of `testOverrides`
triggerConfig, reporter, summary, isTunnelEnabled) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    const publicIdOrPlaceholder = (0, internal_1.getPublicIdOrPlaceholder)({ public_id: (0, internal_1.getTriggerConfigPublicId)(triggerConfig) });
    const normalizedId = (0, exports.normalizePublicId)(publicIdOrPlaceholder);
    if (!normalizedId) {
        throw new errors_1.CriticalError('INVALID_CONFIG', `No valid public ID found in: \`${publicIdOrPlaceholder}\``);
    }
    const testResult = yield (0, test_1.getTest)(api, triggerConfig);
    if ('errorMessage' in testResult) {
        summary.testsNotFound.add(normalizedId);
        return { errorMessage: testResult.errorMessage };
    }
    // TODO SYNTH-12989: Clean up deprecated `config` in favor of `testOverrides`
    triggerConfig.testOverrides = (0, compatibility_1.replaceConfigWithTestOverrides)(triggerConfig.config, triggerConfig.testOverrides);
    const { test } = testResult;
    const overriddenConfig = (0, exports.makeTestPayload)(test, triggerConfig, normalizedId);
    const testExecutionRule = (_c = (_b = test === null || test === void 0 ? void 0 : test.options) === null || _b === void 0 ? void 0 : _b.ci) === null || _c === void 0 ? void 0 : _c.executionRule;
    const executionRule = overriddenConfig.executionRule || testExecutionRule || interfaces_1.ExecutionRule.BLOCKING;
    reporter.testTrigger(test, normalizedId, executionRule, triggerConfig.testOverrides);
    if (executionRule === interfaces_1.ExecutionRule.SKIPPED) {
        summary.skipped++;
        return { overriddenConfig };
    }
    reporter.testWait(test);
    if (isTunnelEnabled && !(0, exports.isTestSupportedByTunnel)(test)) {
        const details = [`public ID: ${normalizedId}`, `type: ${test.type}`];
        if (test.subtype) {
            details.push(`sub-type: ${test.subtype}`);
        }
        if (test.subtype === 'multi') {
            const unsupportedStepSubTypes = (test.config.steps || [])
                .filter((step) => step.subtype !== 'http')
                .map(({ subtype }) => subtype);
            details.push(`step sub-types: [${unsupportedStepSubTypes.join(', ')}]`);
        }
        throw new errors_1.CriticalError('TUNNEL_NOT_SUPPORTED', `The tunnel is only supported with HTTP API tests and Browser tests (${details.join(', ')}).`);
    }
    return { test, overriddenConfig };
});
exports.getTestAndOverrideConfig = getTestAndOverrideConfig;
const isDeviceIdSet = (result) => 'device' in result && result.device !== undefined;
exports.isDeviceIdSet = isDeviceIdSet;
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const getTestsToTrigger = (api, triggerConfigs, reporter, triggerFromSearch, failOnMissingTests, isTunnelEnabled) => __awaiter(void 0, void 0, void 0, function* () {
    const errorMessages = [];
    // TODO SYNTH-12989: Clean up deprecated `config` in favor of `testOverrides`
    triggerConfigs = triggerConfigs.map((triggerConfig) => (Object.assign(Object.assign({}, triggerConfig), { testOverrides: (0, compatibility_1.replaceConfigWithTestOverrides)(triggerConfig.config, triggerConfig.testOverrides) })));
    // When too many tests are triggered, if fetched from a search query: simply trim them and show a warning,
    // otherwise: retrieve them and fail later if still exceeding without skipped/missing tests.
    if (triggerFromSearch && triggerConfigs.length > run_tests_command_1.MAX_TESTS_TO_TRIGGER) {
        const testsCount = triggerConfigs.length;
        triggerConfigs.splice(run_tests_command_1.MAX_TESTS_TO_TRIGGER);
        const maxTests = chalk_1.default.bold(run_tests_command_1.MAX_TESTS_TO_TRIGGER);
        errorMessages.push(chalk_1.default.yellow(`The search query returned ${testsCount} tests, only the first ${maxTests} will be triggered.\n`));
    }
    const initialSummary = (0, exports.createInitialSummary)();
    const testsAndConfigsOverride = yield Promise.all(triggerConfigs.map((triggerConfig) => (0, exports.getTestAndOverrideConfig)(api, triggerConfig, reporter, initialSummary, isTunnelEnabled)));
    yield (0, mobile_1.uploadMobileApplicationsAndUpdateOverrideConfigs)(api, triggerConfigs, testsAndConfigsOverride.filter(internal_1.isMobileTestWithOverride));
    const overriddenTestsToTrigger = [];
    const waitedTests = [];
    testsAndConfigsOverride.forEach((item) => {
        if ('errorMessage' in item) {
            errorMessages.push(item.errorMessage);
        }
        if ('overriddenConfig' in item) {
            overriddenTestsToTrigger.push(item.overriddenConfig);
        }
        if ('test' in item) {
            waitedTests.push(item.test);
        }
    });
    // Display errors at the end of all tests for better visibility.
    reporter.initErrors(errorMessages);
    if (failOnMissingTests && initialSummary.testsNotFound.size > 0) {
        const testsNotFoundListStr = [...initialSummary.testsNotFound].join(', ');
        throw new errors_1.CiError('MISSING_TESTS', testsNotFoundListStr);
    }
    if (!overriddenTestsToTrigger.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    else if (overriddenTestsToTrigger.length > run_tests_command_1.MAX_TESTS_TO_TRIGGER) {
        throw new errors_1.CriticalError('TOO_MANY_TESTS_TO_TRIGGER', `Cannot trigger more than ${run_tests_command_1.MAX_TESTS_TO_TRIGGER} tests (received ${triggerConfigs.length})`);
    }
    return { tests: waitedTests, overriddenTestsToTrigger, initialSummary };
});
exports.getTestsToTrigger = getTestsToTrigger;
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const runTests = (api, testsToTrigger, selectiveRerun, batchTimeout = run_tests_command_1.DEFAULT_BATCH_TIMEOUT) => __awaiter(void 0, void 0, void 0, function* () {
    var _d;
    // TODO SYNTH-12989: Remove this when `pollingTimeout` is removed
    // Although the backend is backwards compatible, let's stop sending deprecated properties
    const tests = testsToTrigger.map((_a) => {
        var { pollingTimeout } = _a, otherProperties = __rest(_a, ["pollingTimeout"]);
        return (Object.assign({}, otherProperties));
    });
    const payload = {
        tests,
        options: {
            batch_timeout: batchTimeout,
            selective_rerun: selectiveRerun,
        },
    };
    const tagsToLimit = {
        [tags_1.GIT_COMMIT_MESSAGE]: 500,
    };
    const ciMetadata = (0, ci_1.getCIMetadata)(tagsToLimit);
    if (ciMetadata) {
        payload.metadata = ciMetadata;
    }
    try {
        return yield api.triggerTests(payload);
    }
    catch (e) {
        const errorMessage = (0, api_1.formatBackendErrors)(e);
        const testIds = testsToTrigger.map((t) => (0, internal_1.getPublicIdOrPlaceholder)(t)).join(',');
        // Rewrite error message
        throw new api_1.EndpointError(`[${testIds}] Failed to trigger tests: ${errorMessage}\n`, (_d = e.response) === null || _d === void 0 ? void 0 : _d.status);
    }
});
exports.runTests = runTests;
const fetchTest = (publicId, config) => __awaiter(void 0, void 0, void 0, function* () {
    const apiHelper = (0, api_1.getApiHelper)(config);
    return apiHelper.getTest(publicId);
});
exports.fetchTest = fetchTest;
const retry = (func, shouldRetryAfterWait) => __awaiter(void 0, void 0, void 0, function* () {
    const trier = (retries = 0) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield func();
        }
        catch (e) {
            const waiter = shouldRetryAfterWait(retries, e);
            if (waiter) {
                yield (0, exports.wait)(waiter);
                return trier(retries + 1);
            }
            throw e;
        }
    });
    return trier();
});
exports.retry = retry;
// TODO SYNTH-12989: Clean up deprecated `variableStrings` in favor of `variables` in `defaultTestOverrides`.
const parseVariablesFromCli = (variableArguments = [], logFunction) => {
    const variables = {};
    for (const variableArgument of variableArguments) {
        const separatorIndex = variableArgument.indexOf('=');
        if (separatorIndex === -1) {
            logFunction(`Ignoring variable "${variableArgument}" as separator "=" was not found`);
            continue;
        }
        if (separatorIndex === 0) {
            logFunction(`Ignoring variable "${variableArgument}" as variable name is empty`);
            continue;
        }
        const key = variableArgument.substring(0, separatorIndex);
        const value = variableArgument.substring(separatorIndex + 1);
        variables[key] = value;
    }
    return Object.keys(variables).length > 0 ? variables : undefined;
};
exports.parseVariablesFromCli = parseVariablesFromCli;
// XXX: `CommandConfig` should be replaced by `SyntheticsCIConfig` here because it's the smallest
//      interface that we need, and it's better semantically.
const getAppBaseURL = ({ datadogSite, subdomain }) => {
    return (0, app_1.getCommonAppBaseURL)(datadogSite, subdomain);
};
exports.getAppBaseURL = getAppBaseURL;
const getBatchUrl = (baseUrl, batchId) => `${baseUrl}synthetics/explorer/ci?batchResultId=${batchId}`;
exports.getBatchUrl = getBatchUrl;
const getResultUrl = (baseUrl, test, resultId, batchId) => {
    const ciQueryParam = `batch_id=${batchId}&from_ci=true`;
    const testDetailUrl = `${baseUrl}synthetics/details/${test.public_id}`;
    if (test.type === 'browser') {
        return `${testDetailUrl}/result/${resultId}?${ciQueryParam}`;
    }
    return `${testDetailUrl}?resultId=${resultId}&${ciQueryParam}`;
};
exports.getResultUrl = getResultUrl;
/**
 * Sort results with the following rules:
 * - Passed results come first
 * - Then non-blocking failed results
 * - And finally failed results
 */
const sortResultsByOutcome = () => {
    const outcomeWeight = {
        ["previously-passed" /* ResultOutcome.PreviouslyPassed */]: 1,
        ["passed-non-blocking" /* ResultOutcome.PassedNonBlocking */]: 2,
        ["passed" /* ResultOutcome.Passed */]: 3,
        ["failed-non-blocking" /* ResultOutcome.FailedNonBlocking */]: 4,
        ["failed" /* ResultOutcome.Failed */]: 5,
    };
    return (r1, r2) => outcomeWeight[(0, exports.getResultOutcome)(r1)] - outcomeWeight[(0, exports.getResultOutcome)(r2)];
};
exports.sortResultsByOutcome = sortResultsByOutcome;
const renderResults = ({ config, orgSettings, reporter, results, startTime, summary, }) => {
    reporter.reportStart({ startTime });
    if (!config.failOnTimeout) {
        if (!summary.timedOut) {
            summary.timedOut = 0;
        }
    }
    if (!config.failOnCriticalErrors) {
        if (!summary.criticalErrors) {
            summary.criticalErrors = 0;
        }
    }
    for (const result of results) {
        if (!config.failOnTimeout && result.timedOut) {
            summary.timedOut++;
        }
        if ((0, internal_1.hasDefinedResult)(result) && result.result.unhealthy && !config.failOnCriticalErrors) {
            summary.criticalErrors++;
        }
        const resultOutcome = (0, exports.getResultOutcome)(result);
        if (result.executionRule !== interfaces_1.ExecutionRule.SKIPPED || resultOutcome === "previously-passed" /* ResultOutcome.PreviouslyPassed */) {
            summary.expected++;
        }
        if (["passed" /* ResultOutcome.Passed */, "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */].includes(resultOutcome)) {
            summary.passed++;
        }
        else if (resultOutcome === "previously-passed" /* ResultOutcome.PreviouslyPassed */) {
            summary.passed++;
            summary.previouslyPassed++;
        }
        else if (resultOutcome === "failed-non-blocking" /* ResultOutcome.FailedNonBlocking */) {
            summary.failedNonBlocking++;
        }
        else {
            summary.failed++;
        }
    }
    reporter.runEnd(summary, (0, exports.getAppBaseURL)(config), orgSettings);
};
exports.renderResults = renderResults;
const reportExitLogs = (reporter, config, { results, error }) => {
    if (!config.failOnTimeout && (results === null || results === void 0 ? void 0 : results.some((result) => result.timedOut))) {
        reporter.error(chalk_1.default.yellow('Because `failOnTimeout` is disabled, the command will succeed. ' +
            'Use `failOnTimeout: true` to make it fail instead.\n'));
    }
    if (!config.failOnCriticalErrors && error instanceof errors_1.CriticalError) {
        reporter.error(chalk_1.default.yellow('Because `failOnCriticalErrors` is not set or disabled, the command will succeed. ' +
            'Use `failOnCriticalErrors: true` to make it fail instead.\n'));
    }
    if (error instanceof errors_1.CiError) {
        (0, exports.reportCiError)(error, reporter);
    }
};
exports.reportExitLogs = reportExitLogs;
const getExitReason = (config, { results, error }) => {
    if (results === null || results === void 0 ? void 0 : results.some((result) => (0, exports.getResultOutcome)(result) === "failed" /* ResultOutcome.Failed */)) {
        return 'failing-tests';
    }
    if (error instanceof errors_1.CiError) {
        // Ensure the command fails if search query starts returning no results
        if (config.failOnMissingTests && ['MISSING_TESTS', 'NO_TESTS_TO_RUN'].includes(error.code)) {
            return 'missing-tests';
        }
        if (error instanceof errors_1.CriticalError) {
            if (config.failOnCriticalErrors) {
                return 'critical-error';
            }
        }
    }
    return 'passed';
};
exports.getExitReason = getExitReason;
const toExitCode = (reason) => {
    return reason === 'passed' ? 0 : 1;
};
exports.toExitCode = toExitCode;
const getDatadogHost = (hostConfig) => {
    const { useIntake, apiVersion, config } = hostConfig;
    const apiPath = apiVersion === 'v1' ? 'api/v1' : 'api/unstable';
    let host = `https://api.${config.datadogSite}`;
    const hostOverride = process_1.default.env.DD_API_HOST_OVERRIDE;
    if (hostOverride) {
        host = hostOverride;
    }
    else if (useIntake && (config.datadogSite === 'datadoghq.com' || config.datadogSite === 'datad0g.com')) {
        host = `https://intake.synthetics.${config.datadogSite}`;
    }
    return `${host}/${apiPath}`;
};
exports.getDatadogHost = getDatadogHost;
const pluralize = (word, count) => (count === 1 ? word : `${word}s`);
exports.pluralize = pluralize;
const reportCiError = (error, reporter) => {
    switch (error.code) {
        case 'NO_TESTS_TO_RUN':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: No tests to run ')}\n${error.message}\n\n`);
            break;
        case 'MISSING_TESTS':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: some tests are missing ')}\n${error.message}\n\n`);
            break;
        // Critical command errors
        case 'AUTHORIZATION_ERROR':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: authorization error ')}\n${error.message}\n\n`);
            reporter.log('Credentials refused, make sure `apiKey`, `appKey` and `datadogSite` are correct.\n');
            break;
        case 'INVALID_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: invalid config ')}\n${error.message}\n\n`);
            break;
        case 'MISSING_APP_KEY':
            reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_APP_KEY')} in your environment.\n`);
            break;
        case 'MISSING_API_KEY':
            reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_API_KEY')} in your environment.\n`);
            break;
        case 'POLL_RESULTS_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to poll test results ')}\n${error.message}\n\n`);
            break;
        case 'BATCH_TIMEOUT_RUNAWAY':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: batch timeout runaway ')}\n${error.message}\n\n`);
            break;
        case 'TUNNEL_START_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to start tunnel ')}\n${error.message}\n\n`);
            break;
        case 'TOO_MANY_TESTS_TO_TRIGGER':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: too many tests to trigger ')}\n${error.message}\n\n`);
            break;
        case 'TRIGGER_TESTS_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to trigger tests ')}\n${error.message}\n\n`);
            break;
        case 'UNAVAILABLE_TEST_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to obtain test configurations with search query ')}\n${error.message}\n\n`);
            break;
        case 'UNAVAILABLE_TUNNEL_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to get tunnel configuration ')}\n${error.message}\n\n`);
            break;
        default:
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR ')}\n${error.message}\n\n`);
    }
};
exports.reportCiError = reportCiError;
//# sourceMappingURL=public.js.map