import { APIHelper } from '../api';
import { CiError } from '../errors';
import { APIHelperConfig, BrowserServerResult, ExecutionRule, MainReporter, Operator, Reporter, Result, ResultDisplayInfo, ResultSkippedBySelectiveRerun, RunTestsCommandConfig, ServerResult, Suite, Summary, SyntheticsCIConfig, SyntheticsOrgSettings, Test, TestNotFound, TestPayload, TestSkipped, TestWithOverride, Trigger, TriggerConfig, UserConfigOverride } from '../interfaces';
import { Tunnel } from '../tunnel';
export declare const PUBLIC_ID_REGEX: RegExp;
export declare const readableOperation: {
    [key in Operator]: string;
};
export declare let ciTriggerApp: string;
export declare const makeTestPayload: (test: Test, triggerConfig: TriggerConfig, publicId: string) => TestPayload;
/** @deprecated This function doesn't work for local test definitions. Please use {@link makeTestPayload} instead. */
export declare const getOverriddenConfig: (test: Test, publicId: string, reporter: MainReporter, testOverrides?: UserConfigOverride) => TestPayload;
export declare const getTestOverridesCount: (testOverrides: UserConfigOverride) => number;
export declare const setCiTriggerApp: (source: string) => void;
export declare const getExecutionRule: (test?: Test, configOverride?: UserConfigOverride) => ExecutionRule;
export declare const getStrictestExecutionRule: (configRule: ExecutionRule, testRule?: ExecutionRule) => ExecutionRule;
export declare const isTestSupportedByTunnel: (test: Test) => boolean | undefined;
/**
 * @deprecated The concept of `ServerResult` is internal and not the source of truth for a result's status. This function has no public equivalent.
 */
export declare const hasResultPassed: (serverResult: ServerResult | undefined, hasTimedOut: boolean, failOnCriticalErrors: boolean, failOnTimeout: boolean) => boolean;
export declare const enum ResultOutcome {
    Passed = "passed",
    PreviouslyPassed = "previously-passed",
    PassedNonBlocking = "passed-non-blocking",
    Failed = "failed",
    FailedNonBlocking = "failed-non-blocking"
}
export declare const PASSED_RESULT_OUTCOMES: ResultOutcome[];
export declare const getResultOutcome: (result: Result) => ResultOutcome;
export declare const getSuites: (GLOB: string, reporter: MainReporter) => Promise<Suite[]>;
export declare const getFilePathRelativeToRepo: (filePath: string) => Promise<string>;
export declare const wait: (duration: number) => Promise<unknown>;
export declare const normalizePublicId: (id: string) => string | undefined;
export declare const getOrgSettings: (reporter: MainReporter, config: SyntheticsCIConfig) => Promise<SyntheticsOrgSettings | undefined>;
export declare const isResultSkippedBySelectiveRerun: (result: Result) => result is ResultSkippedBySelectiveRerun;
export declare const waitForResults: (api: APIHelper, trigger: Trigger, tests: Test[], options: ResultDisplayInfo['options'], reporter: MainReporter, tunnel?: Tunnel) => Promise<Result[]>;
export type InitialSummary = Omit<Summary, 'batchId'>;
export declare const createInitialSummary: () => InitialSummary;
/**
 * @deprecated Please use `Result.duration` instead.
 */
export declare const getResultDuration: (result: ServerResult) => number;
export declare const getReporter: (reporters: Reporter[]) => MainReporter;
export declare const getTestAndOverrideConfig: (api: APIHelper, triggerConfig: TriggerConfig, reporter: MainReporter, summary: InitialSummary, isTunnelEnabled?: boolean) => Promise<TestNotFound | TestSkipped | TestWithOverride>;
export declare const isDeviceIdSet: (result: ServerResult) => result is Required<BrowserServerResult>;
export declare const getTestsToTrigger: (api: APIHelper, triggerConfigs: TriggerConfig[], reporter: MainReporter, triggerFromSearch?: boolean, failOnMissingTests?: boolean, isTunnelEnabled?: boolean) => Promise<{
    tests: Test[];
    overriddenTestsToTrigger: TestPayload[];
    initialSummary: InitialSummary;
}>;
export declare const runTests: (api: APIHelper, testsToTrigger: TestPayload[], selectiveRerun?: boolean, batchTimeout?: number) => Promise<Trigger>;
export declare const fetchTest: (publicId: string, config: SyntheticsCIConfig) => Promise<Test>;
export declare const retry: <T, E extends Error>(func: () => Promise<T>, shouldRetryAfterWait: (retries: number, error: E) => number | undefined) => Promise<T>;
export declare const parseVariablesFromCli: (variableArguments: string[] | undefined, logFunction: (log: string) => void) => {
    [key: string]: string;
} | undefined;
export declare const getAppBaseURL: ({ datadogSite, subdomain }: Pick<RunTestsCommandConfig, 'datadogSite' | 'subdomain'>) => string;
export declare const getBatchUrl: (baseUrl: string, batchId: string) => string;
export declare const getResultUrl: (baseUrl: string, test: Test, resultId: string, batchId: string) => string;
/**
 * Sort results with the following rules:
 * - Passed results come first
 * - Then non-blocking failed results
 * - And finally failed results
 */
export declare const sortResultsByOutcome: () => (r1: Result, r2: Result) => number;
export declare const renderResults: ({ config, orgSettings, reporter, results, startTime, summary, }: {
    config: RunTestsCommandConfig;
    orgSettings: SyntheticsOrgSettings | undefined;
    reporter: MainReporter;
    results: Result[];
    startTime: number;
    summary: Summary;
}) => void;
export declare const reportExitLogs: (reporter: MainReporter, config: Pick<RunTestsCommandConfig, 'failOnTimeout' | 'failOnCriticalErrors'>, { results, error }: {
    results?: Result[] | undefined;
    error?: unknown;
}) => void;
export declare const getExitReason: (config: Pick<RunTestsCommandConfig, 'failOnCriticalErrors' | 'failOnMissingTests'>, { results, error }: {
    results?: Result[] | undefined;
    error?: unknown;
}) => "passed" | "failing-tests" | "missing-tests" | "critical-error";
export type ExitReason = ReturnType<typeof getExitReason>;
export declare const toExitCode: (reason: ExitReason) => 0 | 1;
export declare const getDatadogHost: (hostConfig: {
    apiVersion: 'v1' | 'unstable';
    config: APIHelperConfig;
    useIntake: boolean;
}) => string;
export declare const pluralize: (word: string, count: number) => string;
export declare const reportCiError: (error: CiError, reporter: MainReporter) => void;
