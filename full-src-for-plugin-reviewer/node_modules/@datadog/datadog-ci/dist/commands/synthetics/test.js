"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeLocalTestDefinition = exports.getTest = exports.getTestsFromSearchQuery = exports.getTestConfigs = void 0;
const chalk_1 = __importDefault(require("chalk"));
const api_1 = require("./api");
const compatibility_1 = require("./compatibility");
const run_tests_command_1 = require("./run-tests-command");
const internal_1 = require("./utils/internal");
const public_1 = require("./utils/public");
const getTestConfigs = (config, reporter, suites = []) => __awaiter(void 0, void 0, void 0, function* () {
    const files = [...config.files];
    // Only auto-discover with the default glob when the user **doesn't give any clue** about which tests to run.
    // If they give any clue (e.g. `publicIds`) without explicitly passing `files`,
    // they might be running the command from their home folder so we shouldn't auto-discover for performance reasons.
    if (config.publicIds.length === 0 && files.length === 0 && suites.length === 0 && !config.testSearchQuery) {
        files.push(run_tests_command_1.DEFAULT_TEST_CONFIG_FILES_GLOB);
    }
    const suitesFromFiles = (yield Promise.all(files.map((glob) => (0, public_1.getSuites)(glob, reporter))))
        .reduce((acc, val) => acc.concat(val), [])
        .filter((suite) => !!suite.content.tests);
    suites.push(...suitesFromFiles);
    (0, compatibility_1.warnIfDeprecatedConfigUsed)(suites, reporter);
    (0, compatibility_1.warnIfDeprecatedPollingTimeoutUsed)(suites, reporter);
    const testConfigs = suites
        .map((suite) => suite.content.tests.map((test) => {
        var _a;
        return Object.assign({ 
            // TODO SYNTH-12989: Clean up deprecated `config` in favor of `testOverrides`
            testOverrides: (0, compatibility_1.replaceConfigWithTestOverrides)(test.config, test.testOverrides), suite: suite.name }, ((0, internal_1.isLocalTriggerConfig)(test)
            ? { local_test_definition: (0, exports.normalizeLocalTestDefinition)(test.local_test_definition) }
            : { id: (_a = (0, public_1.normalizePublicId)(test.id)) !== null && _a !== void 0 ? _a : '' }));
    }))
        .reduce((acc, suiteTests) => acc.concat(suiteTests), []);
    return testConfigs;
});
exports.getTestConfigs = getTestConfigs;
const getTestsFromSearchQuery = (api, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { defaultTestOverrides, testSearchQuery } = config;
    // Empty search queries are not allowed.
    if (!testSearchQuery) {
        return [];
    }
    const testSearchResults = yield api.searchTests(testSearchQuery);
    return testSearchResults.tests.map((test) => ({
        testOverrides: defaultTestOverrides !== null && defaultTestOverrides !== void 0 ? defaultTestOverrides : {},
        id: test.public_id,
        suite: `Query: ${testSearchQuery}`,
    }));
});
exports.getTestsFromSearchQuery = getTestsFromSearchQuery;
const getTest = (api, triggerConfig) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if ((0, internal_1.isLocalTriggerConfig)(triggerConfig)) {
        const test = Object.assign(Object.assign({}, triggerConfig.local_test_definition), { suite: triggerConfig.suite });
        return { test };
    }
    const { id: publicId, suite } = triggerConfig;
    try {
        const test = Object.assign(Object.assign({}, (yield api.getTest(publicId))), { suite });
        return { test };
    }
    catch (error) {
        if ((0, api_1.isNotFoundError)(error)) {
            const errorMessage = (0, api_1.formatBackendErrors)(error);
            return { errorMessage: `[${chalk_1.default.bold.dim(publicId)}] ${chalk_1.default.yellow.bold('Test not found')}: ${errorMessage}` };
        }
        throw new api_1.EndpointError(`Failed to get test: ${(0, api_1.formatBackendErrors)(error)}\n`, (_a = error.response) === null || _a === void 0 ? void 0 : _a.status);
    }
});
exports.getTest = getTest;
const normalizeLocalTestDefinition = (localTestDefinition) => {
    // Support links here too for QoL and consistency with `RemoteTriggerConfig.id`
    const publicId = localTestDefinition.public_id && (0, public_1.normalizePublicId)(localTestDefinition.public_id);
    return Object.assign(Object.assign({}, localTestDefinition), { public_id: publicId });
};
exports.normalizeLocalTestDefinition = normalizeLocalTestDefinition;
//# sourceMappingURL=test.js.map