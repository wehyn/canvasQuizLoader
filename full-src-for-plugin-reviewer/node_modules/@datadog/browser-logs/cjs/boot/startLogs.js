"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startLogs = startLogs;
const browser_core_1 = require("@datadog/browser-core");
const logsSessionManager_1 = require("../domain/logsSessionManager");
const assembly_1 = require("../domain/assembly");
const consoleCollection_1 = require("../domain/console/consoleCollection");
const reportCollection_1 = require("../domain/report/reportCollection");
const networkErrorCollection_1 = require("../domain/networkError/networkErrorCollection");
const runtimeErrorCollection_1 = require("../domain/runtimeError/runtimeErrorCollection");
const lifeCycle_1 = require("../domain/lifeCycle");
const loggerCollection_1 = require("../domain/logger/loggerCollection");
const startLogsBatch_1 = require("../transport/startLogsBatch");
const startLogsBridge_1 = require("../transport/startLogsBridge");
const internalContext_1 = require("../domain/contexts/internalContext");
const reportError_1 = require("../domain/reportError");
const logsTelemetry_1 = require("../domain/logsTelemetry");
function startLogs(initConfiguration, configuration, getCommonContext, 
// `startLogs` and its subcomponents assume tracking consent is granted initially and starts
// collecting logs unconditionally. As such, `startLogs` should be called with a
// `trackingConsentState` set to "granted".
trackingConsentState) {
    const lifeCycle = new lifeCycle_1.LifeCycle();
    const cleanupTasks = [];
    lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, (log) => (0, browser_core_1.sendToExtension)('logs', log));
    const reportError = (0, reportError_1.startReportError)(lifeCycle);
    const pageExitObservable = (0, browser_core_1.createPageExitObservable)(configuration);
    const session = configuration.sessionStoreStrategyType && !(0, browser_core_1.canUseEventBridge)() && !(0, browser_core_1.willSyntheticsInjectRum)()
        ? (0, logsSessionManager_1.startLogsSessionManager)(configuration, trackingConsentState)
        : (0, logsSessionManager_1.startLogsSessionManagerStub)(configuration);
    const { stop: stopLogsTelemetry } = (0, logsTelemetry_1.startLogsTelemetry)(initConfiguration, configuration, reportError, pageExitObservable, session);
    cleanupTasks.push(() => stopLogsTelemetry());
    (0, networkErrorCollection_1.startNetworkErrorCollection)(configuration, lifeCycle);
    (0, runtimeErrorCollection_1.startRuntimeErrorCollection)(configuration, lifeCycle);
    (0, consoleCollection_1.startConsoleCollection)(configuration, lifeCycle);
    (0, reportCollection_1.startReportCollection)(configuration, lifeCycle);
    const { handleLog } = (0, loggerCollection_1.startLoggerCollection)(lifeCycle);
    (0, assembly_1.startLogsAssembly)(session, configuration, lifeCycle, getCommonContext, reportError);
    if (!(0, browser_core_1.canUseEventBridge)()) {
        const { stop: stopLogsBatch } = (0, startLogsBatch_1.startLogsBatch)(configuration, lifeCycle, reportError, pageExitObservable, session);
        cleanupTasks.push(() => stopLogsBatch());
    }
    else {
        (0, startLogsBridge_1.startLogsBridge)(lifeCycle);
    }
    const internalContext = (0, internalContext_1.startInternalContext)(session);
    return {
        handleLog,
        getInternalContext: internalContext.get,
        stop: () => {
            cleanupTasks.forEach((task) => task());
        },
    };
}
//# sourceMappingURL=startLogs.js.map