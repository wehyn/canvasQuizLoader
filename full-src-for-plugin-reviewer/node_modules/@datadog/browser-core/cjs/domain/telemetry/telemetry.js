"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startTelemetry = startTelemetry;
exports.startFakeTelemetry = startFakeTelemetry;
exports.drainPreStartTelemetry = drainPreStartTelemetry;
exports.resetTelemetry = resetTelemetry;
exports.isTelemetryReplicationAllowed = isTelemetryReplicationAllowed;
exports.addTelemetryDebug = addTelemetryDebug;
exports.addTelemetryError = addTelemetryError;
exports.addTelemetryConfiguration = addTelemetryConfiguration;
exports.addTelemetryUsage = addTelemetryUsage;
exports.formatError = formatError;
exports.scrubCustomerFrames = scrubCustomerFrames;
const display_1 = require("../../tools/display");
const error_1 = require("../error/error");
const handlingStack_1 = require("../../tools/stackTrace/handlingStack");
const experimentalFeatures_1 = require("../../tools/experimentalFeatures");
const configuration_1 = require("../configuration");
const observable_1 = require("../../tools/observable");
const timeUtils_1 = require("../../tools/utils/timeUtils");
const monitor_1 = require("../../tools/monitor");
const sendToExtension_1 = require("../../tools/sendToExtension");
const numberUtils_1 = require("../../tools/utils/numberUtils");
const jsonStringify_1 = require("../../tools/serialisation/jsonStringify");
const mergeInto_1 = require("../../tools/mergeInto");
const computeStackTrace_1 = require("../../tools/stackTrace/computeStackTrace");
const connectivity_1 = require("../connectivity");
const boundedBuffer_1 = require("../../tools/boundedBuffer");
const rawTelemetryEvent_types_1 = require("./rawTelemetryEvent.types");
const ALLOWED_FRAME_URLS = [
    'https://www.datadoghq-browser-agent.com',
    'https://www.datad0g-browser-agent.com',
    'https://d3uc069fcn7uxw.cloudfront.net',
    'https://d20xtzwzcl0ceb.cloudfront.net',
    'http://localhost',
    '<anonymous>',
];
const TELEMETRY_EXCLUDED_SITES = [configuration_1.INTAKE_SITE_US1_FED];
// eslint-disable-next-line local-rules/disallow-side-effects
let preStartTelemetryBuffer = (0, boundedBuffer_1.createBoundedBuffer)();
let onRawTelemetryEventCollected = (event) => {
    preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event));
};
function startTelemetry(telemetryService, configuration) {
    let contextProvider;
    const observable = new observable_1.Observable();
    const alreadySentEvents = new Set();
    const telemetryEnabled = !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && (0, numberUtils_1.performDraw)(configuration.telemetrySampleRate);
    const telemetryEnabledPerType = {
        [rawTelemetryEvent_types_1.TelemetryType.log]: telemetryEnabled,
        [rawTelemetryEvent_types_1.TelemetryType.configuration]: telemetryEnabled && (0, numberUtils_1.performDraw)(configuration.telemetryConfigurationSampleRate),
        [rawTelemetryEvent_types_1.TelemetryType.usage]: telemetryEnabled && (0, numberUtils_1.performDraw)(configuration.telemetryUsageSampleRate),
    };
    const runtimeEnvInfo = getRuntimeEnvInfo();
    onRawTelemetryEventCollected = (rawEvent) => {
        const stringifiedEvent = (0, jsonStringify_1.jsonStringify)(rawEvent);
        if (telemetryEnabledPerType[rawEvent.type] &&
            alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&
            !alreadySentEvents.has(stringifiedEvent)) {
            const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo);
            observable.notify(event);
            (0, sendToExtension_1.sendToExtension)('telemetry', event);
            alreadySentEvents.add(stringifiedEvent);
        }
    };
    (0, monitor_1.startMonitorErrorCollection)(addTelemetryError);
    function toTelemetryEvent(telemetryService, event, runtimeEnvInfo) {
        return (0, mergeInto_1.combine)({
            type: 'telemetry',
            date: (0, timeUtils_1.timeStampNow)(),
            service: telemetryService,
            version: "6.5.1",
            source: 'browser',
            _dd: {
                format_version: 2,
            },
            telemetry: (0, mergeInto_1.combine)(event, {
                runtime_env: runtimeEnvInfo,
                connectivity: (0, connectivity_1.getConnectivity)(),
                sdk_setup: "npm",
            }),
            experimental_features: Array.from((0, experimentalFeatures_1.getExperimentalFeatures)()),
        }, contextProvider !== undefined ? contextProvider() : {});
    }
    return {
        setContextProvider: (provider) => {
            contextProvider = provider;
        },
        observable,
        enabled: telemetryEnabled,
    };
}
function getRuntimeEnvInfo() {
    return {
        is_local_file: window.location.protocol === 'file:',
        is_worker: 'WorkerGlobalScope' in self,
    };
}
function startFakeTelemetry() {
    const events = [];
    onRawTelemetryEventCollected = (event) => {
        events.push(event);
    };
    return events;
}
// need to be called after telemetry context is provided and observers are registered
function drainPreStartTelemetry() {
    preStartTelemetryBuffer.drain();
}
function resetTelemetry() {
    preStartTelemetryBuffer = (0, boundedBuffer_1.createBoundedBuffer)();
    onRawTelemetryEventCollected = (event) => {
        preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event));
    };
}
/**
 * Avoid mixing telemetry events from different data centers
 * but keep replicating staging events for reliability
 */
function isTelemetryReplicationAllowed(configuration) {
    return configuration.site === configuration_1.INTAKE_SITE_STAGING;
}
function addTelemetryDebug(message, context) {
    (0, monitor_1.displayIfDebugEnabled)(display_1.ConsoleApiName.debug, message, context);
    onRawTelemetryEventCollected({
        type: rawTelemetryEvent_types_1.TelemetryType.log,
        message,
        status: "debug" /* StatusType.debug */,
        ...context,
    });
}
function addTelemetryError(e, context) {
    onRawTelemetryEventCollected({
        type: rawTelemetryEvent_types_1.TelemetryType.log,
        status: "error" /* StatusType.error */,
        ...formatError(e),
        ...context,
    });
}
function addTelemetryConfiguration(configuration) {
    onRawTelemetryEventCollected({
        type: rawTelemetryEvent_types_1.TelemetryType.configuration,
        configuration,
    });
}
function addTelemetryUsage(usage) {
    onRawTelemetryEventCollected({
        type: rawTelemetryEvent_types_1.TelemetryType.usage,
        usage,
    });
}
function formatError(e) {
    if ((0, error_1.isError)(e)) {
        const stackTrace = (0, computeStackTrace_1.computeStackTrace)(e);
        return {
            error: {
                kind: stackTrace.name,
                stack: (0, handlingStack_1.toStackTraceString)(scrubCustomerFrames(stackTrace)),
            },
            message: stackTrace.message,
        };
    }
    return {
        error: {
            stack: error_1.NO_ERROR_STACK_PRESENT_MESSAGE,
        },
        message: `${"Uncaught" /* NonErrorPrefix.UNCAUGHT */} ${(0, jsonStringify_1.jsonStringify)(e)}`,
    };
}
function scrubCustomerFrames(stackTrace) {
    stackTrace.stack = stackTrace.stack.filter((frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url.startsWith(allowedFrameUrl)));
    return stackTrace;
}
//# sourceMappingURL=telemetry.js.map