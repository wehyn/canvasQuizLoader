"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawReportType = void 0;
exports.initReportObservable = initReportObservable;
const handlingStack_1 = require("../../tools/stackTrace/handlingStack");
const monitor_1 = require("../../tools/monitor");
const observable_1 = require("../../tools/observable");
const addEventListener_1 = require("../../browser/addEventListener");
const stringUtils_1 = require("../../tools/utils/stringUtils");
const error_types_1 = require("../error/error.types");
const timeUtils_1 = require("../../tools/utils/timeUtils");
exports.RawReportType = {
    intervention: 'intervention',
    deprecation: 'deprecation',
    cspViolation: 'csp_violation',
};
function initReportObservable(configuration, apis) {
    const observables = [];
    if (apis.includes(exports.RawReportType.cspViolation)) {
        observables.push(createCspViolationReportObservable(configuration));
    }
    const reportTypes = apis.filter((api) => api !== exports.RawReportType.cspViolation);
    if (reportTypes.length) {
        observables.push(createReportObservable(reportTypes));
    }
    return (0, observable_1.mergeObservables)(...observables);
}
function createReportObservable(reportTypes) {
    return new observable_1.Observable((observable) => {
        if (!window.ReportingObserver) {
            return;
        }
        const handleReports = (0, monitor_1.monitor)((reports, _) => reports.forEach((report) => observable.notify(buildRawReportErrorFromReport(report))));
        const observer = new window.ReportingObserver(handleReports, {
            types: reportTypes,
            buffered: true,
        });
        observer.observe();
        return () => {
            observer.disconnect();
        };
    });
}
function createCspViolationReportObservable(configuration) {
    return new observable_1.Observable((observable) => {
        const { stop } = (0, addEventListener_1.addEventListener)(configuration, document, "securitypolicyviolation" /* DOM_EVENT.SECURITY_POLICY_VIOLATION */, (event) => {
            observable.notify(buildRawReportErrorFromCspViolation(event));
        });
        return stop;
    });
}
function buildRawReportErrorFromReport(report) {
    const { type, body } = report;
    return buildRawReportError({
        type: body.id,
        message: `${type}: ${body.message}`,
        originalError: report,
        stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),
    });
}
function buildRawReportErrorFromCspViolation(event) {
    const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`;
    return buildRawReportError({
        type: event.effectiveDirective,
        message: `${exports.RawReportType.cspViolation}: ${message}`,
        originalError: event,
        csp: {
            disposition: event.disposition,
        },
        stack: buildStack(event.effectiveDirective, event.originalPolicy
            ? `${message} of the policy "${(0, stringUtils_1.safeTruncate)(event.originalPolicy, 100, '...')}"`
            : 'no policy', event.sourceFile, event.lineNumber, event.columnNumber),
    });
}
function buildRawReportError(partial) {
    return {
        startClocks: (0, timeUtils_1.clocksNow)(),
        source: error_types_1.ErrorSource.REPORT,
        handling: "unhandled" /* ErrorHandling.UNHANDLED */,
        ...partial,
    };
}
function buildStack(name, message, sourceFile, lineNumber, columnNumber) {
    return sourceFile
        ? (0, handlingStack_1.toStackTraceString)({
            name,
            message,
            stack: [
                {
                    func: '?',
                    url: sourceFile,
                    line: lineNumber !== null && lineNumber !== void 0 ? lineNumber : undefined,
                    column: columnNumber !== null && columnNumber !== void 0 ? columnNumber : undefined,
                },
            ],
        })
        : undefined;
}
//# sourceMappingURL=reportObservable.js.map