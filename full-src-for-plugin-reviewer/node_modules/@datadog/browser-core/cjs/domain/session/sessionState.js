"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXPIRED = void 0;
exports.getExpiredSessionState = getExpiredSessionState;
exports.isSessionInNotStartedState = isSessionInNotStartedState;
exports.isSessionStarted = isSessionStarted;
exports.isSessionInExpiredState = isSessionInExpiredState;
exports.expandSessionState = expandSessionState;
exports.toSessionString = toSessionString;
exports.toSessionState = toSessionState;
const objectUtils_1 = require("../../tools/utils/objectUtils");
const polyfills_1 = require("../../tools/utils/polyfills");
const timeUtils_1 = require("../../tools/utils/timeUtils");
const stringUtils_1 = require("../../tools/utils/stringUtils");
const sessionConstants_1 = require("./sessionConstants");
const sessionStateValidation_1 = require("./sessionStateValidation");
exports.EXPIRED = '1';
function getExpiredSessionState(previousSessionState, configuration) {
    const expiredSessionState = {
        isExpired: exports.EXPIRED,
    };
    if (configuration.trackAnonymousUser) {
        if (previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId) {
            expiredSessionState.anonymousId = previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId;
        }
        else {
            expiredSessionState.anonymousId = (0, stringUtils_1.generateUUID)();
        }
    }
    return expiredSessionState;
}
function isSessionInNotStartedState(session) {
    return (0, objectUtils_1.isEmptyObject)(session);
}
function isSessionStarted(session) {
    return !isSessionInNotStartedState(session);
}
function isSessionInExpiredState(session) {
    return session.isExpired !== undefined || !isActiveSession(session);
}
// An active session is a session in either `Tracked` or `NotTracked` state
function isActiveSession(sessionState) {
    // created and expire can be undefined for versions which was not storing them
    // these checks could be removed when older versions will not be available/live anymore
    return ((sessionState.created === undefined || (0, timeUtils_1.dateNow)() - Number(sessionState.created) < sessionConstants_1.SESSION_TIME_OUT_DELAY) &&
        (sessionState.expire === undefined || (0, timeUtils_1.dateNow)() < Number(sessionState.expire)));
}
function expandSessionState(session) {
    session.expire = String((0, timeUtils_1.dateNow)() + sessionConstants_1.SESSION_EXPIRATION_DELAY);
}
function toSessionString(session) {
    return ((0, polyfills_1.objectEntries)(session)
        // we use `aid` as a key for anonymousId
        .map(([key, value]) => (key === 'anonymousId' ? `aid=${value}` : `${key}=${value}`))
        .join(sessionStateValidation_1.SESSION_ENTRY_SEPARATOR));
}
function toSessionState(sessionString) {
    const session = {};
    if ((0, sessionStateValidation_1.isValidSessionString)(sessionString)) {
        sessionString.split(sessionStateValidation_1.SESSION_ENTRY_SEPARATOR).forEach((entry) => {
            const matches = sessionStateValidation_1.SESSION_ENTRY_REGEXP.exec(entry);
            if (matches !== null) {
                const [, key, value] = matches;
                if (key === 'aid') {
                    // we use `aid` as a key for anonymousId
                    session.anonymousId = value;
                }
                else {
                    session[key] = value;
                }
            }
        });
    }
    return session;
}
//# sourceMappingURL=sessionState.js.map