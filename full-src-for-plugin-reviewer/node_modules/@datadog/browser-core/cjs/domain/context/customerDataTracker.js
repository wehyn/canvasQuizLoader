"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BYTES_COMPUTATION_THROTTLING_DELAY = exports.CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = exports.CUSTOMER_DATA_BYTES_LIMIT = void 0;
exports.createCustomerDataTrackerManager = createCustomerDataTrackerManager;
exports.createCustomerDataTracker = createCustomerDataTracker;
const byteUtils_1 = require("../../tools/utils/byteUtils");
const functionUtils_1 = require("../../tools/utils/functionUtils");
const jsonStringify_1 = require("../../tools/serialisation/jsonStringify");
const display_1 = require("../../tools/display");
const objectUtils_1 = require("../../tools/utils/objectUtils");
// RUM and logs batch bytes limit is 16KB
// ensure that we leave room for other event attributes and maintain a decent amount of event per batch
// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB
exports.CUSTOMER_DATA_BYTES_LIMIT = 3 * byteUtils_1.ONE_KIBI_BYTE;
// We observed that the compression ratio is around 8 in general, but we also want to keep a margin
// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB
// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this
// is a bit arbitrary.
exports.CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * byteUtils_1.ONE_KIBI_BYTE;
exports.BYTES_COMPUTATION_THROTTLING_DELAY = 200;
function createCustomerDataTrackerManager(compressionStatus = 2 /* CustomerDataCompressionStatus.Disabled */) {
    const customerDataTrackers = new Map();
    let alreadyWarned = false;
    function checkCustomerDataLimit(initialBytesCount = 0) {
        if (alreadyWarned || compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {
            return;
        }
        const bytesCountLimit = compressionStatus === 2 /* CustomerDataCompressionStatus.Disabled */
            ? exports.CUSTOMER_DATA_BYTES_LIMIT
            : exports.CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT;
        let bytesCount = initialBytesCount;
        customerDataTrackers.forEach((tracker) => {
            bytesCount += tracker.getBytesCount();
        });
        if (bytesCount > bytesCountLimit) {
            displayCustomerDataLimitReachedWarning(bytesCountLimit);
            alreadyWarned = true;
        }
    }
    return {
        /**
         * Creates a detached tracker. The manager will not store a reference to that tracker, and the
         * bytes count will be counted independently from other detached trackers.
         *
         * This is particularly useful when we don't know when the tracker will be unused, so we don't
         * leak memory (ex: when used in Logger instances).
         */
        createDetachedTracker: () => {
            const tracker = createCustomerDataTracker(() => checkCustomerDataLimit(tracker.getBytesCount()));
            return tracker;
        },
        /**
         * Creates a tracker if it doesn't exist, and returns it.
         */
        getOrCreateTracker: (type) => {
            if (!customerDataTrackers.has(type)) {
                customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit));
            }
            return customerDataTrackers.get(type);
        },
        setCompressionStatus: (newCompressionStatus) => {
            if (compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {
                compressionStatus = newCompressionStatus;
                checkCustomerDataLimit();
            }
        },
        getCompressionStatus: () => compressionStatus,
        stop: () => {
            customerDataTrackers.forEach((tracker) => tracker.stop());
            customerDataTrackers.clear();
        },
    };
}
function createCustomerDataTracker(checkCustomerDataLimit) {
    let bytesCountCache = 0;
    // Throttle the bytes computation to minimize the impact on performance.
    // Especially useful if the user call context APIs synchronously multiple times in a row
    const { throttled: computeBytesCountThrottled, cancel: cancelComputeBytesCount } = (0, functionUtils_1.throttle)((context) => {
        bytesCountCache = (0, byteUtils_1.computeBytesCount)((0, jsonStringify_1.jsonStringify)(context));
        checkCustomerDataLimit();
    }, exports.BYTES_COMPUTATION_THROTTLING_DELAY);
    const resetBytesCount = () => {
        cancelComputeBytesCount();
        bytesCountCache = 0;
    };
    return {
        updateCustomerData: (context) => {
            if ((0, objectUtils_1.isEmptyObject)(context)) {
                resetBytesCount();
            }
            else {
                computeBytesCountThrottled(context);
            }
        },
        resetCustomerData: resetBytesCount,
        getBytesCount: () => bytesCountCache,
        stop: () => {
            cancelComputeBytesCount();
        },
    };
}
function displayCustomerDataLimitReachedWarning(bytesCountLimit) {
    display_1.display.warn(`Customer data exceeds the recommended ${bytesCountLimit / byteUtils_1.ONE_KIBI_BYTE}KiB threshold. ${display_1.MORE_DETAILS} ${display_1.DOCS_TROUBLESHOOTING}/#customer-data-exceeds-the-recommended-threshold-warning`);
}
//# sourceMappingURL=customerDataTracker.js.map