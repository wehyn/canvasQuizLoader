"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHandlingStack = createHandlingStack;
exports.toStackTraceString = toStackTraceString;
exports.formatErrorMessage = formatErrorMessage;
const monitor_1 = require("../monitor");
const computeStackTrace_1 = require("./computeStackTrace");
/**
 * Creates a stacktrace without SDK internal frames.
 * Constraints:
 * - Has to be called at the utmost position of the call stack.
 * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.
 */
function createHandlingStack(type) {
    /**
     * Skip the two internal frames:
     * - SDK API (console.error, ...)
     * - this function
     * in order to keep only the user calls
     */
    const internalFramesToSkip = 2;
    const error = new Error(type);
    error.name = 'HandlingStack';
    let formattedStack;
    (0, monitor_1.callMonitored)(() => {
        const stackTrace = (0, computeStackTrace_1.computeStackTrace)(error);
        stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);
        formattedStack = toStackTraceString(stackTrace);
    });
    return formattedStack;
}
function toStackTraceString(stack) {
    let result = formatErrorMessage(stack);
    stack.stack.forEach((frame) => {
        const func = frame.func === '?' ? '<anonymous>' : frame.func;
        const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : '';
        const line = frame.line ? `:${frame.line}` : '';
        const column = frame.line && frame.column ? `:${frame.column}` : '';
        result += `\n  at ${func}${args} @ ${frame.url}${line}${column}`;
    });
    return result;
}
function formatErrorMessage(stack) {
    return `${stack.name || 'Error'}: ${stack.message}`;
}
//# sourceMappingURL=handlingStack.js.map