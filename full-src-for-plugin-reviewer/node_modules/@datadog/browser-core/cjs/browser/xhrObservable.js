"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initXhrObservable = initXhrObservable;
const instrumentMethod_1 = require("../tools/instrumentMethod");
const observable_1 = require("../tools/observable");
const timeUtils_1 = require("../tools/utils/timeUtils");
const urlPolyfill_1 = require("../tools/utils/urlPolyfill");
const objectUtils_1 = require("../tools/utils/objectUtils");
const addEventListener_1 = require("./addEventListener");
let xhrObservable;
const xhrContexts = new WeakMap();
function initXhrObservable(configuration) {
    if (!xhrObservable) {
        xhrObservable = createXhrObservable(configuration);
    }
    return xhrObservable;
}
function createXhrObservable(configuration) {
    return new observable_1.Observable((observable) => {
        const { stop: stopInstrumentingStart } = (0, instrumentMethod_1.instrumentMethod)(XMLHttpRequest.prototype, 'open', openXhr);
        const { stop: stopInstrumentingSend } = (0, instrumentMethod_1.instrumentMethod)(XMLHttpRequest.prototype, 'send', (call) => {
            sendXhr(call, configuration, observable);
        }, { computeHandlingStack: true });
        const { stop: stopInstrumentingAbort } = (0, instrumentMethod_1.instrumentMethod)(XMLHttpRequest.prototype, 'abort', abortXhr);
        return () => {
            stopInstrumentingStart();
            stopInstrumentingSend();
            stopInstrumentingAbort();
        };
    });
}
function openXhr({ target: xhr, parameters: [method, url] }) {
    xhrContexts.set(xhr, {
        state: 'open',
        method: String(method).toUpperCase(),
        url: (0, urlPolyfill_1.normalizeUrl)(String(url)),
    });
}
function sendXhr({ target: xhr, handlingStack }, configuration, observable) {
    const context = xhrContexts.get(xhr);
    if (!context) {
        return;
    }
    const startContext = context;
    startContext.state = 'start';
    startContext.startClocks = (0, timeUtils_1.clocksNow)();
    startContext.isAborted = false;
    startContext.xhr = xhr;
    startContext.handlingStack = handlingStack;
    let hasBeenReported = false;
    const { stop: stopInstrumentingOnReadyStateChange } = (0, instrumentMethod_1.instrumentMethod)(xhr, 'onreadystatechange', () => {
        if (xhr.readyState === XMLHttpRequest.DONE) {
            // Try to report the XHR as soon as possible, because the XHR may be mutated by the
            // application during a future event. For example, Angular is calling .abort() on
            // completed requests during an onreadystatechange event, so the status becomes '0'
            // before the request is collected.
            onEnd();
        }
    });
    const onEnd = () => {
        unsubscribeLoadEndListener();
        stopInstrumentingOnReadyStateChange();
        if (hasBeenReported) {
            return;
        }
        hasBeenReported = true;
        const completeContext = context;
        completeContext.state = 'complete';
        completeContext.duration = (0, timeUtils_1.elapsed)(startContext.startClocks.timeStamp, (0, timeUtils_1.timeStampNow)());
        completeContext.status = xhr.status;
        observable.notify((0, objectUtils_1.shallowClone)(completeContext));
    };
    const { stop: unsubscribeLoadEndListener } = (0, addEventListener_1.addEventListener)(configuration, xhr, 'loadend', onEnd);
    observable.notify(startContext);
}
function abortXhr({ target: xhr }) {
    const context = xhrContexts.get(xhr);
    if (context) {
        context.isAborted = true;
    }
}
//# sourceMappingURL=xhrObservable.js.map